
Примеры AST:
 Num: 1
 BinaryOp: +
   Num: 1
   Num: 2
 Parens:
   BinaryOp: *
     Num: 3
     Num: 4
 BinaryOp: +
   Num: 1
   BinaryOp: *
     Num: 2
     Num: 3

lein test compiler.ast-test

lein test compiler.lexer-test

lein test compiler.parser-test

lein test :only compiler.parser-test/parse-parens-test

FAIL in (parse-parens-test) (parser_test.clj:21)
Парсинг выражений в скобках
expected: (= [(->Parens (->Num 42)) []] (parse-parens ["(" "42" ")"]))
  actual: (not (= [#compiler.ast.Parens{:expr #compiler.ast.Num{:value 42}} []] nil))

lein test :only compiler.parser-test/parse-parens-test

FAIL in (parse-parens-test) (parser_test.clj:22)
Парсинг выражений в скобках
expected: (= [(->Parens (->BinaryOp "+" (->Num 1) (->Num 2))) []] (parse-parens ["(" "1" "+" "2" ")"]))
  actual: (not (= [#compiler.ast.Parens{:expr #compiler.ast.BinaryOp{:op "+", :left #compiler.ast.Num{:value 1}, :right #compiler.ast.Num{:value 2}}} []] nil))

Тест 1: Простое числовое выражение
Входная строка: 42
Токены: [[:number 42]]
AST: #compiler.ast.Num{:value 42}

Тест 2: Бинарная операция
Входная строка: 1+2
Токены: [[:number 1] [:operator +] [:number 2]]
AST: nil

lein test :only compiler.parser-test/full-pipeline-test

FAIL in (full-pipeline-test) (parser_test.clj:81)
Полный пайплайн: лексический анализ -> парсинг -> AST
expected: (= (->BinaryOp "+" (->Num 1) (->Num 2)) ast)
  actual: (not (= #compiler.ast.BinaryOp{:op "+", :left #compiler.ast.Num{:value 1}, :right #compiler.ast.Num{:value 2}} nil))

Тест 3: Выражение со скобками
Входная строка: (1+2)*3
Токены: [[:open-paren (] [:number 1] [:operator +] [:number 2] [:close-paren )] [:operator *] [:number 3]]
AST: nil

lein test :only compiler.parser-test/full-pipeline-test

FAIL in (full-pipeline-test) (parser_test.clj:91)
Полный пайплайн: лексический анализ -> парсинг -> AST
expected: (= (->BinaryOp "*" (->Parens (->BinaryOp "+" (->Num 1) (->Num 2))) (->Num 3)) ast)
  actual: (not (= #compiler.ast.BinaryOp{:op "*", :left #compiler.ast.Parens{:expr #compiler.ast.BinaryOp{:op "+", :left #compiler.ast.Num{:value 1}, :right #compiler.ast.Num{:value 2}}}, :right #compiler.ast.Num{:value 3}} nil))

Тест 4: Комплексное выражение
Входная строка: 1+2*3
Токены: [[:number 1] [:operator +] [:number 2] [:operator *] [:number 3]]
AST: nil

lein test :only compiler.parser-test/full-pipeline-test

FAIL in (full-pipeline-test) (parser_test.clj:104)
Полный пайплайн: лексический анализ -> парсинг -> AST
expected: (= (->BinaryOp "+" (->Num 1) (->BinaryOp "*" (->Num 2) (->Num 3))) ast)
  actual: (not (= #compiler.ast.BinaryOp{:op "+", :left #compiler.ast.Num{:value 1}, :right #compiler.ast.BinaryOp{:op "*", :left #compiler.ast.Num{:value 2}, :right #compiler.ast.Num{:value 3}}} nil))

lein test :only compiler.parser-test/parse-test

FAIL in (parse-test) (parser_test.clj:36)
Парсинг полных выражений
expected: (= (->BinaryOp "+" (->Num 1) (->Num 2)) (parse "1+2"))
  actual: (not (= #compiler.ast.BinaryOp{:op "+", :left #compiler.ast.Num{:value 1}, :right #compiler.ast.Num{:value 2}} nil))

lein test :only compiler.parser-test/parse-test

FAIL in (parse-test) (parser_test.clj:37)
Парсинг полных выражений
expected: (= (->BinaryOp "*" (->Parens (->BinaryOp "+" (->Num 1) (->Num 2))) (->Num 3)) (parse "(1+2)*3"))
  actual: (not (= #compiler.ast.BinaryOp{:op "*", :left #compiler.ast.Parens{:expr #compiler.ast.BinaryOp{:op "+", :left #compiler.ast.Num{:value 1}, :right #compiler.ast.Num{:value 2}}}, :right #compiler.ast.Num{:value 3}} nil))

lein test :only compiler.parser-test/parse-number-test

FAIL in (parse-number-test) (parser_test.clj:15)
Парсинг числовых литералов
expected: (= [(->Num 42) []] (parse-number ["42"]))
  actual: (not (= [#compiler.ast.Num{:value 42} []] nil))

lein test :only compiler.parser-test/parse-number-test

FAIL in (parse-number-test) (parser_test.clj:16)
Парсинг числовых литералов
expected: (= [(->Num -42) []] (parse-number ["-42"]))
  actual: (not (= [#compiler.ast.Num{:value -42} []] nil))

lein test :only compiler.parser-test/parse-binary-op-test

FAIL in (parse-binary-op-test) (parser_test.clj:28)
Парсинг бинарных операций
expected: (= [(->BinaryOp "+" (->Num 1) (->Num 2)) []] (parse-binary-op ["1" "+" "2"]))
  actual: (not (= [#compiler.ast.BinaryOp{:op "+", :left #compiler.ast.Num{:value 1}, :right #compiler.ast.Num{:value 2}} []] nil))

lein test :only compiler.parser-test/parse-binary-op-test

FAIL in (parse-binary-op-test) (parser_test.clj:30)
Парсинг бинарных операций
expected: (= [(->BinaryOp "*" (->Num 3) (->Num 4)) []] (parse-binary-op ["3" "*" "4"]))
  actual: (not (= [#compiler.ast.BinaryOp{:op "*", :left #compiler.ast.Num{:value 3}, :right #compiler.ast.Num{:value 4}} []] nil))

lein test :only compiler.parser-test/operator-precedence-test

FAIL in (operator-precedence-test) (parser_test.clj:45)
Проверка приоритета операторов
expected: (= (->BinaryOp "+" (->Num 1) (->BinaryOp "*" (->Num 2) (->Num 3))) (parse "1+2*3"))
  actual: (not (= #compiler.ast.BinaryOp{:op "+", :left #compiler.ast.Num{:value 1}, :right #compiler.ast.BinaryOp{:op "*", :left #compiler.ast.Num{:value 2}, :right #compiler.ast.Num{:value 3}}} nil))

lein test :only compiler.parser-test/operator-precedence-test

FAIL in (operator-precedence-test) (parser_test.clj:49)
Проверка приоритета операторов
expected: (= (->BinaryOp "*" (->BinaryOp "+" (->Num 1) (->Num 2)) (->Num 3)) (parse "(1+2)*3"))
  actual: (not (= #compiler.ast.BinaryOp{:op "*", :left #compiler.ast.BinaryOp{:op "+", :left #compiler.ast.Num{:value 1}, :right #compiler.ast.Num{:value 2}}, :right #compiler.ast.Num{:value 3}} nil))

lein test :only compiler.parser-test/tokenize-test

FAIL in (tokenize-test) (parser_test.clj:9)
Токенизация базовых выражений
expected: (= ["1" "+" "2"] (tokenize "1+2"))
  actual: (not (= ["1" "+" "2"] [[:number "1"] [:operator "+"] [:number "2"]]))

lein test :only compiler.parser-test/tokenize-test

FAIL in (tokenize-test) (parser_test.clj:10)
Токенизация базовых выражений
expected: (= ["(" "1" "+" "2" ")" "*" "3"] (tokenize "(1+2)*3"))
  actual: (not (= ["(" "1" "+" "2" ")" "*" "3"] [[:open-paren "("] [:number "1"] [:operator "+"] [:number "2"] [:close-paren ")"] [:operator "*"] [:number "3"]]))

lein test :only compiler.parser-test/tokenize-test

FAIL in (tokenize-test) (parser_test.clj:11)
Токенизация базовых выражений
expected: (= ["-42" "/" "2"] (tokenize "-42/2"))
  actual: (not (= ["-42" "/" "2"] [[:number "-42"] [:operator "/"] [:number "2"]]))

Ran 17 tests containing 41 assertions.
16 failures, 0 errors.
